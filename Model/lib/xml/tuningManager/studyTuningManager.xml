<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>
  <!-- TODO:  add filterValue here if/when Dataset specific run gets Samples;
              until then this query will return zero rows in clinepi context -->
  <tuningTable name="SampleId" prefixEnabled="true">
    <comment>Which protocol app nodes for sample record
    </comment>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixSampleId&1 AS
        SELECT pan.protocol_app_node_id as pan_id, pan.name as pan_name,
               pi.name as project_id
        FROM study.ProtocolAppNode pan, core.ProjectInfo pi
        WHERE pan.isa_type = 'Sample'
          AND pan.row_project_id = pi.project_id
        UNION
        SELECT pan.protocol_app_node_id as pan_id, pan.name as pan_name,
               pi.name as project_id
        FROM study.Study s, sres.ExternalDatabase d,
             sres.ExternalDatabaseRelease r, study.ProtocolAppNode pan,
             study.StudyLink sl, core.ProjectInfo pi
        WHERE s.external_database_release_id = r.external_database_release_id
          AND r.external_database_id = d.external_database_id
          AND s.study_id = sl.study_id
          AND pan.row_project_id = pi.project_id
          AND sl.protocol_app_node_id = pan.protocol_app_node_id
          AND d.name like '%isolates_genbank_RSRC'
        -- using column positions, rather than column names, in ORDER BY on union
        ORDER BY 2, 1
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyRelation" prefixEnabled="true">
    <comment>Each record represents a parent-child relation within an ontology
             dataset. Used to build the Ontology tuning table, which adds info
             particular to a (data) dataset, such as property types and
             dataset-specific display names.
    </comment>
    <internalDependency name="HierarchyMap"/>
    <externalDependency name="sres.OntologyRelationship"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixOntologyRelation&1 AS
        SELECT ed.name as hierarchy_dataset_name,
               edr.external_database_release_id as hierarchy_dataset_release_id,
               child.ontology_term_id as child_ontology_term_id,
               child.source_id as child_ontology_term_source_id,
               parent.ontology_term_id as parent_ontology_term_id,
               parent.source_id as parent_ontology_term_source_id
        FROM sres.OntologyRelationship orel, sres.OntologyTerm parent, sres.OntologyTerm child,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
        WHERE orel.subject_term_id = child.ontology_term_id
          AND orel.object_term_id = parent.ontology_term_id
          AND orel.subject_term_id != orel.object_term_id -- work around ICEMR bug
          AND orel.object_term_id
              not in (SELECT ontology_term_id FROM sres.OntologyTerm WHERE lower(name) = 'thing')
          AND orel.external_database_release_id = edr.external_database_release_id
          AND (orel.predicate_term_id is null
               or orel.predicate_term_id
                  in (SELECT ontology_term_id FROM sres.OntologyTerm WHERE source_id = 'subClassOf'))
          AND edr.external_database_id = ed.external_database_id
          AND ed.name in (SELECT hierarchy_dataset_name FROM &prefixHierarchyMap)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixOrelIx&1
        on &prefixOntologyRelation&1 (hierarchy_dataset_name, child_ontology_term_id, parent_ontology_term_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixOrelUqIx&1
        on &prefixOntologyRelation&1 (hierarchy_dataset_name, child_ontology_term_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="OntologyAncestor" prefixEnabled="true">
   <comment>
     (term, ancestor term, ontology) 3-tuples
   </comment>
    <internalDependency name="OntologyRelation"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixOntologyAncestor&1 AS
        WITH RECURSIVE cte AS (
            SELECT hierarchy_dataset_name, child_ontology_term_id as ontology_term_id,
                    parent_ontology_term_id as ancestor_ontology_term_id
            FROM &prefixOntologyRelation
            WHERE (hierarchy_dataset_name, child_ontology_term_id) IN (
                SELECT hierarchy_dataset_name, child_ontology_term_id
                FROM &prefixOntologyRelation
            )
            UNION
            SELECT p.hierarchy_dataset_name, cte.ontology_term_id,
                p.parent_ontology_term_id as ancestor_ontology_term_id
            FROM &prefixOntologyRelation p, cte
            WHERE p.child_ontology_term_id = cte.ancestor_ontology_term_id
                AND p.hierarchy_dataset_name = cte.hierarchy_dataset_name
        )
        SELECT hierarchy_dataset_name, ontology_term_id, ancestor_ontology_term_id
        FROM cte
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixontac&1_uqix
               on &prefixOntologyAncestor&1 (hierarchy_dataset_name, ontology_term_id, ancestor_ontology_term_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="DatasetTerm" prefixEnabled="true">
   <comment></comment>
    <internalDependency name="HierarchyMap"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologySynonym"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixDatasetTerm&1 AS
        SELECT DISTINCT ed.name as hierarchy_dataset_name, ot.ontology_term_id,
                        ot.source_id, syn.ontology_synonym as name,
                        syn.definition, cast(null as varchar(10)) as display_order, cast(null as varchar(10)) as variable
        FROM sres.OntologyTerm ot, sres.OntologySynonym syn,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed
        WHERE ot.ontology_term_id = syn.ontology_term_id
          AND syn.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ed.name in (SELECT hierarchy_dataset_name FROM &prefixHierarchyMap)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixdt&1_uqix
               on &prefixDatasetTerm&1 (hierarchy_dataset_name, ontology_term_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixdt&1_1ix
               on &prefixDatasetTerm&1 (hierarchy_dataset_name, ontology_term_id, source_id, name)

      ]]>
    </sql>
  </tuningTable>

  <!-- renamed from ProtocolAppNodeRecord -->
  <tuningTable name="PANRecord" prefixEnabled="true">
   <comment>Input to pan meta data tables</comment>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPanRecord&1 AS
        SELECT DISTINCT pan.protocol_app_node_id as pan_id, pan.name as pan_name,
                        pan.isa_type as pan_isa_type, ot.name as pan_type,
                        ot.source_id as pan_type_source_id,
                        ot.ontology_term_id as pan_type_id
        FROM study.ProtocolAppNode pan, sres.OntologyTerm ot, study.StudyLink sl,
             study.Study s, sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
        WHERE ot.ontology_term_id = pan.type_id
          AND pan.protocol_app_node_id = sl.protocol_app_node_id
          AND sl.study_id = s.study_id
          AND s.external_database_release_id = r.external_database_release_id
          AND r.external_database_id = d.external_database_id
          AND (ot.source_id
               in ('EUPATH_0000738', --Observation/Event
                   'PCO_0000024', -- Household
                   'EUPATH_0000096', --Participant
                   'EUPATH_0000327', -- CDC light trap
                   'EUPATH_0025169', -- Insect sample
                   'EUPATH_0035127', -- Community
                   'OBI_0100051','EUPATH_0000609' -- SPecimentype (need to replace with specimen)
                  )
               or pan.isa_type = 'Sample'
              )
          AND (d.name = '&filterValue' or coalesce('&filterValue', '0') = '0')
        ORDER BY pan.name
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PANResults" prefixEnabled="true">
    <comment>Table of protocol app node ids and the name of the result table where they are referenced
    </comment>
    <internalDependency name="PANExtDbRls"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <externalDependency name="apidb.CrisprPhenotype"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.RflpGenotype"/>
    <externalDependency name="apidb.RflpGenotypeNumber"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.EditingEvent"/>
    <externalDependency name="results.FamilyDiffResult"/>
    <externalDependency name="results.FamilyExpression"/>
    <externalDependency name="results.GeneDiffResult"/>
    <externalDependency name="results.GeneExpression"/>
    <externalDependency name="results.GeneSimilarity"/>
    <externalDependency name="results.LineageAbundance"/>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="results.ReporterDiffResult"/>
    <externalDependency name="results.ReporterExpression"/>
    <externalDependency name="results.ReporterIntensity"/>
    <externalDependency name="results.RnaDiffResult"/>
    <externalDependency name="results.RnaExpression"/>
    <externalDependency name="results.SegmentDiffResult"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPANResults&1 AS
        SELECT DISTINCT r.*
        FROM (
          SELECT protocol_app_node_id as pan_id, 'Results::NAFeatureDiffResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.NAFeatureDiffResult)
        UNION
          SELECT protocol_app_node_id, 'Results::ReporterIntensity' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.ReporterIntensity)
        UNION
          SELECT protocol_app_node_id, 'Results::SegmentResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.SegmentResult)
        UNION
          SELECT protocol_app_node_id, 'Results::CompoundMassSpec' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.CompoundMassSpec)
        UNION
          SELECT protocol_app_node_id, 'Results::NaFeatureHostResponse' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.NaFeatureHostResponse)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::ChrCopyNumber' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM ApiDB.ChrCopyNumber)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::GeneCopyNumber' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM ApiDB.GeneCopyNumber)
        UNION
          SELECT protocol_app_node_id, 'Results::NAFeatureExpression' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.NAFeatureExpression)
        UNION
          SELECT protocol_app_node_id, 'Results::EditingEvent' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.EditingEvent)
        UNION
          SELECT protocol_app_node_id, 'Results::FamilyDiffResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.FamilyDiffResult)
        UNION
          SELECT protocol_app_node_id, 'Results::FamilyExpression' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.FamilyExpression)
        UNION
          SELECT protocol_app_node_id, 'Results::GeneDiffResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.GeneDiffResult)
        UNION
          SELECT protocol_app_node_id, 'Results::GeneExpression' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.GeneExpression)
        UNION
          SELECT protocol_app_node_id, 'Results::GeneSimilarity' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.GeneSimilarity)
        UNION
          SELECT protocol_app_node_id, 'Results::ReporterDiffResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.ReporterDiffResult)
        UNION
          SELECT protocol_app_node_id, 'Results::ReporterExpression' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.ReporterExpression)
        UNION
          SELECT protocol_app_node_id, 'Results::RnaDiffResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.RnaDiffResult)
        UNION
          SELECT protocol_app_node_id, 'Results::RnaExpression' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.RnaExpression)
        UNION
          SELECT protocol_app_node_id, 'Results::LineageAbundance' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.LineageAbundance)
        UNION
          SELECT protocol_app_node_id, 'Results::SegmentDiffResult' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.SegmentDiffResult)
        UNION
          SELECT protocol_app_node_id, 'Results::SeqVariation' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM Results.SeqVariation)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::SequenceVariation' as result_table FROM study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM study.ProtocolAppNode WHERE name like '% (Sequence Variation)')
        UNION
          SELECT protocol_app_node_id, 'ApiDB::MassSpecSummary' as result_table from study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM apidb.MASSSPECSUMMARY)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::IntronJunction' as result_table from study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM apidb.IntronJunction)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::RflpGenotype' as result_table from study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM apidb.RflpGenotype)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::RflpGenotypeNumber' as result_table from study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM apidb.RflpGenotypeNumber)
        UNION
          SELECT protocol_app_node_id, 'ApiDB::CrisprPhenotype' as result_table from study.ProtocolAppNode
          WHERE protocol_app_node_id in (select protocol_app_node_id FROM apidb.crisprphenotype)
        ) r, &prefixpanextdbrls panExtDbRls
        WHERE r.pan_id = panExtDbRls.pan_id
          AND (panExtDbRls.dataset_name = '&filterValue' or length('&filterValue') = 0)
      ]]>
    </sql>
  </tuningTable>

   <!-- renamed from ProtocolAppNodeIO -->
  <tuningTable name="PANIO" prefixEnabled="true">
   <comment>ALL inputs and outputs</comment>
    <internalDependency name="PANExtDbRls"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPANIO&1 AS
        SELECT DISTINCT io.*
        FROM (
          SELECT i.protocol_app_node_id input_pan_id, pa.protocol_app_id,
                 o.protocol_app_node_id output_pan_id,
                 in_type.source_id as input_pan_type_source_id,
                 --in_type.name as input_pan_type,
                 in_type.ontology_term_id as input_pan_type_id,
                 out_type.source_id as output_pan_type_source_id,
                 --out_type.name as output_pan_type,
                 out_type.ontology_term_id as output_pan_type_id
          FROM study.ProtocolApp pa, study.Input i, study.Output o,
               study.ProtocolAppNode in_pan LEFT JOIN sres.OntologyTerm in_type ON in_pan.type_id = in_type.ontology_term_id,
               study.ProtocolAppNode out_pan LEFT JOIN sres.OntologyTerm out_type ON out_pan.type_id = out_type.ontology_term_id
          WHERE i.protocol_app_id = pa.protocol_app_id
            AND o.protocol_app_id = pa.protocol_app_id
            AND i.protocol_app_node_id = in_pan.protocol_app_node_id
            AND o.protocol_app_node_id = out_pan.protocol_app_node_id
        ) io, &prefixpanextdbrls panExtDbRls
        WHERE io.input_pan_id = panExtDbRls.pan_id -- the input and outputs will have same dataset in prefix enabled mode only
          AND (panExtDbRls.dataset_name = '&filterValue' or length('&filterValue') = 0)
        ORDER BY io.input_pan_id, io.output_pan_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_iix&1 on &prefixPANIO&1
               (input_pan_id, output_pan_id, protocol_app_id, input_pan_type_source_id, output_pan_type_source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_oix&1 on &prefixPANIO&1
               (output_pan_id, input_pan_id, protocol_app_id, input_pan_type_source_id, output_pan_type_source_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_otypeix&1 on &prefixPANIO&1
               (output_pan_type_source_id, input_pan_type_source_id, output_pan_id, input_pan_id, protocol_app_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpainio2_itypeix&1 on &prefixPANIO&1
               (input_pan_type_source_id, output_pan_type_source_id, input_pan_id, output_pan_id, protocol_app_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HierarchyMap" prefixEnabled="true">
    <comment>Maps each dataset name to the name of the external database to use for ontology synonyms and relationships
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.Study"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixHierarchyMap&1 AS
        SELECT datasets.dataset_name,
               coalesce(dynamic_mapping.hierarchy, hardwired_hierarchy) as hierarchy_dataset_name
        FROM
          (SELECT name as dataset_name,
                   case
                     when lower(name) like '%microarrayantibody%'
                          and name not like '%Helb_RecentExposure%'
                       then 'Ontology_icemr_RSRC'
                     when lower(name) like 'otu%'
                       then 'OntologyTerm_microbiome_RSRC'
                     else 'OntologyTerm_eupath_isa_RSRC'
                   end as hardwired_hierarchy
            FROM sres.ExternalDatabase
            WHERE external_database_id
                  in (SELECT edr.external_database_id
                      FROM sres.ExternalDatabaseRelease edr, study.Study s
                      WHERE s.external_database_release_id = edr.external_database_release_id)
              AND (name = '&filterValue' or length('&filterValue') = 0)
          ) datasets LEFT JOIN
          (SELECT dsp.name as dataset_name, d.name as hierarchy
            FROM DatasetPresenter dsp, DatasetProperty p, sres.ExternalDatabase d
             WHERE p.property = 'webDisplayOntologyName'
              AND dsp.dataset_presenter_id = p.dataset_presenter_id
              AND 'OntologyTerm_' || p.value || '_RSRC' = d.name
          ) dynamic_mapping ON datasets.dataset_name = dynamic_mapping.dataset_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixhmap_ix0&1
        on &prefixHierarchyMap&1 (dataset_name, hierarchy_dataset_name)

      ]]>
    </sql>
  </tuningTable>

   <!-- renamed from PANExternalDatabaseRelease -->
  <tuningTable name="PANExtDbRls" prefixEnabled="true">
   <comment>ALL inputs and outputs</comment>
    <externalDependency name="study.NodeSet"/>
    <externalDependency name="study.NodeNodeSet"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPANExtDbRls&1 AS
        SELECT distinct protocol_app_node_id as pan_id, external_database_release_id, name as dataset_name
        FROM (
          SELECT
            sl.protocol_app_node_id
          , s.external_database_release_id
          , d.name
          FROM
            study.nodeSet s
          , study.nodeNodeSet sl
          , sres.externaldatabaserelease r
          , sres.externaldatabase d
          WHERE
            s.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and s.node_set_id = sl.node_set_id
            and s.external_database_release_id is not null
          UNION
          SELECT pan.protocol_app_node_id
          , pan.external_database_release_id
          , d.name
          FROM study.protocolappnode pan
          , sres.externaldatabaserelease r
          , sres.externaldatabase d
          WHERE
            pan.external_database_release_id = r.external_database_release_id
            and r.external_database_id = d.external_database_id
            and pan.external_database_release_id is not null
        ) t
        WHERE (name = '&filterValue' or length('&filterValue') = 0)
        ORDER BY external_database_release_id, protocol_app_node_id
      ]]>
    </sql>
  </tuningTable>

  <!-- Renamed from PANProtocolMetadata -->
  <tuningTable name="InferredParams" prefixEnabled="true">
    <comment>
    </comment>
    <internalDependency name="DatasetTerm"/>
    <internalDependency name="HierarchyMap"/>
    <internalDependency name="PANIO"/>
    <internalDependency name="PANResults"/>
    <internalDependency name="SampleId"/>
    <internalDependency name="PANRecord"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <ancillaryTable name="ValueCaps"/>
    <ancillaryTable name="InferredChars"/> <!-- renamed from PANCHaracteristicMetadata -->
    <ancillaryTable name="SampleProcess"/> <!-- renamed from SampleDownstream -->
    <ancillaryTable name="PANUpstream"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPANUpstream&1 AS
        SELECT *
        FROM (
          WITH RECURSIVE cte AS (
            SELECT output_pan_id, input_pan_id, protocol_app_id
            FROM apidbtuning.panio
            WHERE output_pan_id IN (
                SELECT pan_id FROM apidbtuning.PANResults
                UNION
                SELECT pan_id FROM apidbtuning.SampleId WHERE project_id not in ('ClinEpiDB')
                UNION
                SELECT protocol_app_node_id FROM study.ProtocolAppNode WHERE isa_type in ('Phenotype','Genotype')
              )
            UNION
            SELECT cte.output_pan_id, p.input_pan_id, p.protocol_app_id
            FROM cte, apidbtuning.panio p
            WHERE cte.input_pan_id = p.output_pan_id
          )
          SELECT output_pan_id as pan_id, input_pan_id, protocol_app_id
          FROM cte
          UNION
            SELECT si.pan_id, si.pan_id as input_node_id, o.protocol_app_id
            FROM &prefixSampleId si LEFT JOIN study.Output o
              ON si.pan_id = o.protocol_app_node_id
          UNION
            SELECT panr.pan_id, panr.pan_id as input_pan_id, o.protocol_app_id
            FROM &prefixPANRecord panr LEFT JOIN study.Output o
              ON panr.pan_id = o.protocol_app_node_id
            WHERE panr.pan_type != 'specimen'
          UNION
            SELECT c.protocol_app_node_id, c.protocol_app_node_id, o.protocol_app_id
            FROM study.Characteristic c LEFT JOIN study.Output o
              ON c.protocol_app_node_id = o.protocol_app_node_id
        ) t
        WHERE pan_id NOT IN (
          SELECT pan.protocol_app_node_id
          FROM study.ProtocolAppNode pan, sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
          WHERE pan.external_database_release_id = edr.external_database_release_id
            AND edr.external_database_id = ed.external_database_id
            AND ed.name like '%_isolates_genbank_RSRC'
        )
        ORDER BY pan_id, protocol_app_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpanup_pix&1 on &prefixPANUpstream&1 (pan_id, input_pan_id, protocol_app_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpanup_iix&1 on &prefixPANUpstream&1 (input_pan_id, pan_id, protocol_app_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixInferredParams&1 AS
        WITH param_term AS (
          SELECT pp.protocol_param_id, ot.ontology_term_id, ot.source_id,
             -- use row_number() to get only the oldest of terms that share a name
            row_number() over (partition by ot.name order by ot.ontology_term_id) as ranking
          FROM study.ProtocolParam pp, sres.OntologyTerm ot
          WHERE ot.name = pp.name
        )
        SELECT distinct node_inputs.pan_id, ot.name as pan_type,
               ot.ontology_term_id as pan_type_id,
               pan.isa_type as pan_isa_type, ds.name as dataset_name,
               p.name as protocol, proto_type.name as protocol_type, p.protocol_type_id,
               pan.name as pan_name, pp.name as property,
               param_term.ontology_term_id as property_id,
               param_term.source_id as property_source_id,
               pap.value, pap.protocol_app_param_id, ds.type as dataset_type, ds.subtype as dataset_subtype, tn.name as organism,
               pp.unit_type_id as unit_id,
               coalesce(mt.name, 'assay') as ancestor_pan_type,
               mt.ontology_term_id as ancestor_pan_type_id
        FROM &prefixPANUpstream&1 node_inputs
          INNER JOIN study.ProtocolAppParam pap ON node_inputs.protocol_app_id = pap.protocol_app_id
          INNER JOIN study.ProtocolParam pp ON pap.protocol_param_id = pp.protocol_param_id
          INNER JOIN study.Protocol p ON pp.protocol_id = p.protocol_id
          INNER JOIN study.StudyLink sl ON node_inputs.pan_id = sl.protocol_app_node_id
          INNER JOIN study.ProtocolAppNode pan ON node_inputs.pan_id = pan.protocol_app_node_id
          INNER JOIN sres.ontologyterm proto_type ON p.protocol_type_id = proto_type.ontology_term_id
          INNER JOIN param_term ON pp.protocol_param_id = param_term.protocol_param_id
          INNER JOIN (
            SELECT s.study_id, i.external_database_release_id
            FROM study.Study s, study.Study i
            WHERE s.investigation_id = i.study_id
            UNION
            SELECT s.study_id, s.external_database_release_id
            FROM study.Study s
          ) study_release ON sl.study_id = study_release.study_id
          INNER JOIN sres.ExternalDatabaseRelease edr ON study_release.external_database_release_id = edr.external_database_release_id
          INNER JOIN sres.ExternalDatabase ed ON edr.external_database_id = ed.external_database_id
          INNER JOIN apidb.Datasource ds ON ed.name = ds.name
          LEFT JOIN sres.ontologyterm ot ON pan.type_id = ot.ontology_term_id
          LEFT JOIN sres.TaxonName tn ON ds.taxon_id = tn.taxon_id
          LEFT JOIN sres.OntologyTerm mt ON pan.type_id = mt.ontology_term_id
        WHERE
          (ed.name = '&filterValue' or length('&filterValue') = 0)
          AND (tn.name_class = 'scientific name' or tn.name_class is null)
          AND p.name not like '%::%' -- avoid Perl class names
          AND p.name not like '%data transformation' -- avoid data transformation protocol parameters
          AND param_term.ranking = 1
        ORDER BY organism, type, subtype, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixInferredParams&1 ip
        SET property
            = (SELECT dt.name
               FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
               WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 AND dt.ontology_term_id = ip.property_id
                 AND hm.dataset_name = ip.dataset_name)
        WHERE property_id
              in (SELECT dt.ontology_term_id
                  FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    AND hm.dataset_name = ip.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixInferredParams&1 ip
        SET pan_type
            = (SELECT dt.name
               FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
               WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 AND dt.ontology_term_id = ip.pan_type_id
                 AND hm.dataset_name = ip.dataset_name)
        WHERE pan_type_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = ip.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixValueCaps&1 AS
        SELECT qualifier_id, lower_value, commonest_capitalization
        FROM (SELECT qualifier_id,
                     cast(value as varchar(3100)) as commonest_capitalization,
                     cast(lower(value) as varchar(3100)) as lower_value,
                     dense_rank() over (partition by qualifier_id, lower(value) order by count(*) desc) as ranking
              FROM study.Characteristic c, study.StudyLink sl, study.Study s,
                   sres.ExternalDatabase d, sres.ExternalDatabaseRelease r
              WHERE c.protocol_app_node_id = sl.protocol_app_node_id
                AND sl.study_id = s.study_id
                AND s.external_database_release_id = r.external_database_release_id
                AND r.external_database_id = d.external_database_id
                AND (d.name = '&filterValue' or length('&filterValue') = 0)
              GROUP BY qualifier_id, value
             ) t
        WHERE ranking = 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixvalcap_ix&1
               on &prefixValueCaps&1 (qualifier_id, lower_value, commonest_capitalization)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixInferredChars&1 AS
        SELECT -- distinct -- should be unneeded and can use too much temp space
          sample_pan.protocol_app_node_id as pan_id,
          sample_ot.name as pan_type,
          sample_ot.ontology_term_id as pan_type_id,
          sample_pan.isa_type as pan_isa_type,
          --pan.protocol_app_node_id as ancestor_pan_id,
          coalesce(mt.name, 'assay') as ancestor_pan_type,
          mt.ontology_term_id as ancestor_pan_type_id,
          CASE
            WHEN attribute_term.source_id = 'EUPATH_0000455'
             -- this term should be replaced by OBI_0003056
            THEN 'Average mapping coverage'
            ELSE attribute_term.name
          END AS property, -- if not a material type it has to be an assay
          attribute_term.ontology_term_id as property_id,
          attribute_term.source_id as property_source_id,
          coalesce(value_term.name, caps.commonest_capitalization) as value,
          value_term.ontology_term_id as value_id, c.characteristic_id,
          ds.name as dataset_name, hm.hierarchy_dataset_name,
          sample_pan.name as pan_name, ds.type as dataset_type,
          ds.subtype as dataset_subtype, tn.name as organism, c.unit_id
        FROM &prefixPANUpstream&1 node_inputs
          INNER JOIN study.ProtocolAppNode pan ON node_inputs.input_pan_id = pan.protocol_app_node_id
          INNER JOIN study.ProtocolAppNode sample_pan ON node_inputs.pan_id = sample_pan.protocol_app_node_id
          INNER JOIN (
            SELECT min(characteristic_id) as characteristic_id,
                    protocol_app_node_id, ontology_term_id, qualifier_id, unit_id, value
             FROM study.Characteristic
             GROUP BY protocol_app_node_id, ontology_term_id, qualifier_id, unit_id, value
          ) c ON pan.protocol_app_node_id = c.protocol_app_node_id
          INNER JOIN (
            SELECT DISTINCT sl.protocol_app_node_id, study_release.external_database_release_id
            FROM study.StudyLink sl,
              (  SELECT s.study_id, i.external_database_release_id
                 FROM study.Study s, study.Study i
                 WHERE s.investigation_id = i.study_id
                 UNION
                 SELECT s.study_id, s.external_database_release_id
                 FROM study.Study s) study_release
            WHERE sl.study_id = study_release.study_id
          ) pan_release ON node_inputs.pan_id = pan_release.protocol_app_node_id
          INNER JOIN sres.ExternalDatabaseRelease edr ON pan_release.external_database_release_id = edr.external_database_release_id
          INNER JOIN sres.ExternalDatabase ed ON edr.external_database_id = ed.external_database_id
          INNER JOIN apidb.Datasource ds ON ed.name = ds.name
          INNER JOIN &prefixHierarchyMap hm ON ds.name = hm.dataset_name
          LEFT JOIN sres.TaxonName tn ON ds.taxon_id = tn.taxon_id
          LEFT JOIN sres.OntologyTerm value_term ON c.ontology_term_id = value_term.ontology_term_id
          LEFT JOIN sres.OntologyTerm attribute_term ON c.qualifier_id = attribute_term.ontology_term_id
          LEFT JOIN sres.OntologyTerm mt ON pan.type_id = mt.ontology_term_id
          LEFT JOIN sres.OntologyTerm sample_ot ON sample_pan.type_id = sample_ot.ontology_term_id
          LEFT JOIN &prefixValueCaps&1 caps ON c.qualifier_id = caps.qualifier_id AND lower(c.value) = caps.lower_value
        WHERE
         (ed.name = '&filterValue' or length('&filterValue') = 0)
         AND (tn.name_class = 'scientific name' or tn.name_class is null)
         -- temporary may need adjusting for RNASeq
         AND (pan.type_id is not null
              OR attribute_term.source_id
                 IN ('GENEPIO_0000092', -- average mapping coverage
                     'EUPATH_0000455'  -- proportion mapped reads
                    )
             )
         --AND ds.name != 'ISASimple_RSRC'
         --AND ds.name != 'ISA_RSRC'
       --ORDER BY organism, type, subtype, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixinfchar_ix&1
               on &prefixInferredChars&1 (pan_id, property_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixInferredChars&1 ic
        SET property
            = (SELECT dt.name
               FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
               WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 AND dt.ontology_term_id = ic.property_id
                 AND hm.dataset_name = ic.dataset_name)
        WHERE property_id
              in (SELECT dt.ontology_term_id
                  FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    AND hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixInferredChars&1 ic
        SET value
            = (SELECT dt.name
               FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
               WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 AND dt.ontology_term_id = ic.value_id
                 AND hm.dataset_name = ic.dataset_name)
        WHERE value_id
              in (SELECT dt.ontology_term_id
                  FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    AND hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixInferredChars&1 ic
        SET pan_type
            = (SELECT dt.name
               FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
               WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 AND dt.ontology_term_id = ic.pan_type_id
                 AND hm.dataset_name = ic.dataset_name)
        WHERE pan_type_id
              in (SELECT dt.ontology_term_id
                  FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    AND hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixInferredChars&1 ic
        SET ancestor_pan_type
            = (SELECT dt.name
               FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
               WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 AND dt.ontology_term_id = ic.ancestor_pan_type_id
                 AND hm.dataset_name = ic.dataset_name)
        WHERE ancestor_pan_type_id
              in (SELECT dt.ontology_term_id
                  FROM &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  WHERE hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    AND hm.dataset_name = ic.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpancharorg_ix&1 on &prefixInferredChars&1 (organism, dataset_type, dataset_subtype, dataset_name, pan_id, pan_name, property, value)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixSampleProcess&1 AS
        SELECT
            p1.name
          , p1.protocol_app_node_id
          , p3.name as input_name
          , p3.protocol_app_node_id as input_pan_id
          , case
              WHEN ot3.name LIKE 'data%'
              THEN 'Data'
              else p3.isa_type
            end as input_isa_type
          , ot3.name as input_material_type
          , p.name AS protocol
          , p2.name AS output_name
          , p2.protocol_app_node_id AS output_pan_id
          , case
              WHEN ot2.name LIKE 'data%'
              THEN 'Data'
              else p2.isa_type
            end as output_isa_type
          , ot2.name AS output_material_type
        FROM
          (
            WITH RECURSIVE cte AS(
              SELECT input_pan_id AS pan_id, input_pan_id, output_pan_id, protocol_app_id
              FROM &prefixpanio
              WHERE input_pan_id IN (SELECT pan_id from &prefixSampleId)
              UNION
              SELECT cte.pan_id as pan_id, p.input_pan_id, p.output_pan_id, p.protocol_app_id
              FROM cte, &prefixpanio p
              WHERE cte.output_pan_id = p.input_pan_id
            )
            SELECT pan_id, input_pan_id, output_pan_id, protocol_app_id
            FROM cte
          ) io
          INNER JOIN study.protocolappnode p1 ON io.pan_id = p1.protocol_app_node_id
          INNER JOIN study.protocolappnode p2 ON io.output_pan_id = p2.protocol_app_node_id
          INNER JOIN study.protocolappnode p3 ON io.input_pan_id = p3.protocol_app_node_id
          INNER JOIN study.protocolapp pa ON io.protocol_app_id = pa.protocol_app_id
          INNER JOIN study.protocol p ON pa.protocol_id = p.protocol_id
          LEFT JOIN sres.ontologyterm ot2 ON p2.type_id = ot2.ontology_term_id
          LEFT JOIN sres.ontologyterm ot3 ON p3.type_id = ot3.ontology_term_id
        ORDER BY name, p1.protocol_app_node_id, input_pan_id, output_pan_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixsampproc_ix&1
             on &prefixSampleProcess&1 (name, output_pan_id)

      ]]>
    </sql>
  </tuningTable>

  <!-- renamed from PANParameterValues -->
  <tuningTable name="PANParamValues" prefixEnabled="true">
    <comment>
    </comment>
    <internalDependency name="PANIO"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
        create table &prefixPANParamValues&1 as
        SELECT
            p.name as protocol
          , pp.name as protocol_param
          , pap.value as protocol_param_value
          , pan.name as protocol_app_node_name
          , pan.protocol_app_node_id
        FROM
            study.protocolappparam pap
          , study.protocolparam pp
          , study.protocol p
          , &prefixpanio io
          , study.protocolappnode pan
        WHERE
          pp.protocol_param_id = pap.protocol_param_id
          AND p.protocol_id = pp.protocol_id
          AND io.protocol_app_id = pap.protocol_app_id
          AND io.output_pan_id = pan.protocol_app_node_id
        ORDER BY protocol_app_node_name
      ]]>
    </sql>
  </tuningTable>

  <!--Renamed from FallbackMetadata -->
  <tuningTable name="DefaultChars" prefixEnabled="true">
    <comment>
      For datasets that have results but no metadata, a fallback set of metadata comprising the name of each ProtocolAppNode
    </comment>
    <internalDependency name="DatasetTerm"/>
    <internalDependency name="PANResults"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixDefaultChars&1 AS
        -- regular query for most datasets
        SELECT ed.name as dataset_name
          , ds.type as dataset_type
          , CASE WHEN ds.type = 'genome'
              THEN 'HTS_SNP'
              ELSE ds.subtype
              END as dataset_subtype
          , tn.name as organism
          , CASE WHEN ds.type = 'genome' THEN o.strain_abbrev ELSE pan.name END AS pan_name
          , pan.protocol_app_node_id as pan_id
          , pan.isa_type as pan_isa_type
          , coalesce(ot.name, 'dataset') as property
          , ot.source_id AS property_source_id
          , ot.ontology_term_id AS property_id
          , study_release.name as study_name
          , CASE
            WHEN ds.type = 'genome'
              THEN tn.name || ' ' || dsp.display_name
            WHEN dsp.display_name IS NULL
              THEN replace(replace(replace(replace(ed.name, 'pfal3D7_microarrayAntibody_', ''),
                                           '_ICEMR_RSRC', ''),
                                   '_RSRC', ''),
                           '_', ' ')
            ELSE dsp.display_name
          END as value,
          coalesce(mt.name, 'assay') as ancestor_pan_type,
          mt.ontology_term_id as ancestor_pan_type_id
        FROM study.ProtocolAppNode pan
          INNER JOIN study.StudyLink sl ON pan.protocol_app_node_id = sl.protocol_app_node_id
          INNER JOIN (
            SELECT s.study_id, i.external_database_release_id, i.name
            FROM study.Study s, study.Study i
            WHERE s.investigation_id = i.study_id
            UNION
            SELECT s.study_id, s.external_database_release_id, s.name
            FROM study.Study s
          ) study_release ON sl.study_id = study_release.study_id
          INNER JOIN sres.ExternalDatabaseRelease edr ON study_release.external_database_release_id = edr.external_database_release_id
          INNER JOIN sres.ExternalDatabase ed ON edr.external_database_id = ed.external_database_id
          INNER JOIN apidb.Datasource ds ON ed.name = replace(ds.name, 'primary_genome_RSRC', 'NGS_SNPsAndVariations')
          --cnv datasets use hts_snp presenters
          LEFT JOIN apidbTuning.DatasetPresenter dsp ON replace(ds.name, 'copyNumberVariations', 'HTS_SNP') = dsp.name
          LEFT JOIN sres.TaxonName tn ON ds.taxon_id = tn.taxon_id
          LEFT JOIN apidb.organism o ON ds.taxon_id = o.taxon_id
          LEFT JOIN sres.OntologyTerm mt ON pan.type_id = mt.ontology_term_id
          CROSS JOIN (
            SELECT max(ontology_term_id) as ontology_term_id,
                   max(source_id) as source_id, max(name) as name
            FROM sres.OntologyTerm
            WHERE source_id = 'IAO_0000100' -- "data set"
          ) ot
        WHERE pan.protocol_app_node_id in (SELECT pan_id FROM &prefixPANResults)
          AND (tn.name_class = 'scientific name' or tn.name_class is null)
          AND (ed.name = '&filterValue' or length('&filterValue') = 0)
        UNION ALL
        -- special query for reference strain
        SELECT ed.name as dataset_name, 'SNP' as dataset_type, 'HTS_SNP' as dataset_subtype,
               tn.name as organism, o.strain_abbrev as pan_name, pan.protocol_app_node_id as pan_id,
               pan.isa_type as pan_isa_type,
               ot.name as property,
               ot.source_id as property_source_id,
               ot.ontology_term_id as property_id,
               study_release.name as study_name, tn.name as value,
               coalesce(mt.name, 'assay') as ancestor_pan_type,
               mt.ontology_term_id as ancestor_pan_type_id
        FROM study.ProtocolAppNode pan
          INNER JOIN study.StudyLink sl ON pan.protocol_app_node_id = sl.protocol_app_node_id
          INNER JOIN (
            SELECT s.study_id, i.external_database_release_id, i.name
            FROM study.Study s, study.Study i
            WHERE s.investigation_id = i.study_id
            UNION
            SELECT s.study_id, s.external_database_release_id, s.name
            FROM study.Study s
          ) study_release ON sl.study_id = study_release.study_id
          INNER JOIN sres.ExternalDatabaseRelease edr ON study_release.external_database_release_id = edr.external_database_release_id
          INNER JOIN sres.ExternalDatabase ed ON edr.external_database_id = ed.external_database_id
          INNER JOIN apidb.Organism o ON o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          LEFT JOIN sres.TaxonName tn ON o.taxon_id = tn.taxon_id
          LEFT JOIN sres.OntologyTerm mt ON pan.type_id = mt.ontology_term_id
          CROSS JOIN sres.OntologyTerm ot
        WHERE pan.protocol_app_node_id in (SELECT pan_id FROM &prefixPANResults)
          AND ed.name like '%_NGS_SNPsAndVariations'
          AND (tn.name_class = 'scientific name' or tn.name_class is null)
          AND (ed.name = '&filterValue' or length('&filterValue') = 0)
          AND ot.source_id
              = case
                  -- is this a FungiDB instance?
                  when lower(substr(current_database(), 1, 4)) = 'fung'
                    then 'NCIT_C14209' -- "Fungal organism"
                  else 'OPL_0000232' -- "parasite organism"
                end
        ORDER BY organism, dataset_name, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixDefaultChars&1 dc
        SET property
            = (select dt.name
               from &prefixHierarchyMap hm, &prefixDatasetTerm dt
               where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                 and dt.ontology_term_id = dc.property_id
                 and hm.dataset_name = dc.dataset_name)
        WHERE property_id
              in (select dt.ontology_term_id
                  from &prefixHierarchyMap hm, &prefixDatasetTerm dt
                  where hm.hierarchy_dataset_name = dt.hierarchy_dataset_name
                    and hm.dataset_name = dc.dataset_name)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixDefaultChars&1 dc
        SET property_source_id = property
        WHERE property_source_id is null
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="DatasetLeafTerm" prefixEnabled="true">
    <comment>
      Ontology terms used in each dataset as properties that have values
    </comment>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixDatasetLeafTerm&1 AS
          SELECT dataset_name, unit_id, property_id
          FROM &prefixInferredParams
        UNION
          SELECT dataset_name, unit_id, property_id
          FROM &prefixInferredChars
        UNION
          SELECT dataset_name, null, property_id
          FROM &prefixDefaultChars
        ORDER BY dataset_name, property_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="MetadataSummary" prefixEnabled="true">
    <comment>
      Summary stats for property values
    </comment>
    <internalDependency name="PropertyType"/>
    <internalDependency name="Metadata"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixMetadataSummary&1 AS
        SELECT s.property_source_id, s.distinct_values, pt.distinct_values as number_distinct_values,
                   null as min, null as max, null as average, null as upper_quartile, null as lower_quartile
        FROM (
          SELECT property_source_id,
                 cast (substr(string_agg(string_value, '|' order by string_value), 1, 3990) as varchar(4000)) as distinct_values
          FROM (
            SELECT distinct m.property_source_id, m.string_value
                FROM &prefixMetadata m,
                     &prefixPropertytype pt
                WHERE m.string_value is not null
                  AND m.property_source_id = pt.property_source_id
                  AND pt.type = 'string'
                  --and pt.distinct_values < 80
          ) t
        GROUP BY property_source_id
        ) s,
        &prefixpropertytype pt
        WHERE pt.property_source_id = s.property_source_id
        UNION
        SELECT n.property_source_id, null as distinct_values, pt.distinct_values as number_distinct_values,
                min, max, average, upper_quartile, lower_quartile
        FROM (
          SELECT m.property_source_id,
                cast(min(m.number_value) as varchar(100)) as min,
                cast(max(m.number_value) as varchar(100)) as max,
                cast(avg(m.number_value) as varchar(100)) as average,
                cast(percentile_disc(.75) within group (order by m.number_value) as varchar(100)) as upper_quartile,
                cast(percentile_disc(.25) within group (order by m.number_value) as varchar(100)) as lower_quartile
          FROM &prefixMetadata m,
            &prefixPropertytype pt
          WHERE m.number_value is not null
            AND m.property_source_id = pt.property_source_id
            AND pt.type = 'number'
          GROUP BY m.property_source_id
        ) n,
        &prefixpropertytype pt
        WHERE pt.property_source_id = n.property_source_id
        UNION
        SELECT d.property_source_id, null as distinct_values, pt.distinct_values as number_distinct_values,
                min, max, null as average, upper_quartile, lower_quartile
        FROM (
              SELECT m.property_source_id,
                  cast(to_char(min(m.date_value),'YYYY-MM-DD') AS varchar(100)) as min,
                  cast(to_char(max(m.date_value),'YYYY-MM-DD') AS varchar(100)) as max,
                  cast(to_char(percentile_disc(.75) within group (order by m.date_value),'YYYY-MM-DD') as varchar(100)) as upper_quartile,
                  cast(to_char(percentile_disc(.25) within group (order by m.date_value),'YYYY-MM-DD') as varchar(100)) as lower_quartile
              FROM &prefixMetadata m,
                &prefixPropertytype pt
              WHERE m.date_value is not null
                AND m.property_source_id = pt.property_source_id
                AND pt.type = 'date'
              GROUP BY m.property_source_id
        ) d,
        &prefixpropertytype pt
        where pt.property_source_id = d.property_source_id
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PropertyCategory" prefixEnabled="true">
    <comment>
      Category (or categories) of each property
    </comment>
    <internalDependency name="Metadata"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPropertyCategory&1 AS
        SELECT DISTINCT property_source_id, dataset_name, category
        FROM &prefixMetadata
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixpcat_ixone&1
        on &prefixPropertyCategory&1 (property_source_id, dataset_name, category)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Metadata" prefixEnabled="true">
    <comment>
      Metadata table for new, wide, strongly-typed filter param
    </comment>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="PropertyType"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixMetadata&1 AS
        SELECT m.dataset_type, m.dataset_subtype, m.organism, m.dataset_name,
               m.pan_id, m.pan_name, m.pan_isa_type,
               m.category, m.property, m.property_id, mt.property_source_id,
               substr(m.value, 1, 250) as string_value,
               case
                 when m.value = lower(m.value)
                      and upper(substr(m.value, 1, 1)) || substr(m.value, 2) != value
                 then 1
                 else 0
               end as capitalization_flag,
               case
                when mt.type = 'number' then apidb.parse_and_round_number(m.value)
                else cast(null as numeric)
               end as number_value,
               case when mt.type = 'date' then apidb.parse_date(m.value) else cast(null as timestamp) end as date_value
        FROM &prefixPropertyType mt,
             (  SELECT dataset_type, dataset_subtype, organism, dataset_name,
                       pan_id, pan_name, pan_isa_type,
                       protocol as category, property, property_id, value
                FROM &prefixInferredParams
              UNION ALL
                SELECT dataset_type, dataset_subtype, organism, dataset_name,
                       pan_id, pan_name, pan_isa_type,
                       ancestor_pan_type as category, property, property_id, value
                FROM &prefixInferredChars
              UNION ALL
                SELECT dataset_type, dataset_subtype, organism, dataset_name,
                       pan_id, pan_name, pan_isa_type,
                       null as category, property, property_id, value
                FROM &prefixDefaultChars
             ) m
        WHERE (m.property_id = mt.property_id
               OR (mt.property_id is null and m.property = mt.property))
        -- ORDER BY organism, dataset_type, dataset_subtype, dataset_name, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        insert into &prefixMetadata&1
        (dataset_type, dataset_subtype, organism, dataset_name, pan_id,
         pan_name, pan_isa_type, category, property, property_id,
         property_source_id, string_value)
        SELECT *
        FROM (
          WITH sample_term
             AS (SELECT max(ontology_term_id) as ontology_term_id,
                        max(source_id) as source_id,
                        max(name) as name
                 FROM sres.OntologyTerm
                 WHERE source_id = 'NCIT_C42614')
          SELECT DISTINCT m.dataset_type, m.dataset_subtype, m.organism, m.dataset_name, m.pan_id,
                 m.pan_name, m.pan_isa_type, m.category,
                 coalesce(st.name, 'Sample name') as property,
                 st.ontology_term_id as property_id,
                 st.source_id as property_source_id,
                 replace(m.pan_name, ' (Sequence Variation)', '') as string_value
          FROM &prefixMetadata&1 m, sample_term st
          WHERE dataset_name
                IN ('cposSilveira_NGS_SNPsAndVariations',
                    'cposSilveira_HTS_SNP_Whole_Population_Genome_SNP_RSRC')
            AND pan_name not like '%(DNA Sequencing)'
            AND dataset_type != 'genome'
            AND category is null
        ) t
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixmwn_ixone&1
          on &prefixMetadata&1 (property_source_id, pan_id, dataset_name, category, string_value, number_value, date_value)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixmwn_ixtwo&1
          on &prefixMetadata&1 (category, property_source_id, pan_id, string_value, number_value, date_value)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Ontology" prefixEnabled="true">
    <comment>
    </comment>
    <internalDependency name="DatasetTerm"/>
    <internalDependency name="DatasetLeafTerm"/>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="HierarchyMap"/>
    <internalDependency name="InferredParams"/>
    <internalDependency name="OntologyAncestor"/>
    <internalDependency name="OntologyRelation"/>
    <internalDependency name="PropertyType"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixOntology&1 AS
        WITH
          DatasetOntologyTerm AS (
            -- a term (leaf or ancestor) of a dataset
            -- ontology terms used as properties (things with values)
            SELECT dataset_name, property_id as ontology_term_id, unit_id
            FROM &prefixDatasetLeafTerm
            UNION
             -- ontology terms with descendants used as properties
            SELECT leaf.dataset_name, ancestor.ancestor_ontology_term_id as ontology_term_id,
                   cast(null as numeric) as unit_id
            FROM &prefixDatasetLeafTerm leaf, &prefixHierarchyMap hmap, &prefixOntologyAncestor ancestor
            WHERE leaf.property_id = ancestor.ontology_term_id
              AND leaf.dataset_name = hmap.dataset_name
              AND hmap.hierarchy_dataset_name = ancestor.hierarchy_dataset_name
          ),
          DatasetInfo AS (
            -- columns that are functions of dataset
            SELECT dataset_name, max(dataset_type) as dataset_type,
                   max(dataset_subtype) as dataset_subtype, max(organism) as organism
            FROM ( SELECT dataset_name, dataset_type, dataset_subtype, organism
                   FROM &prefixInferredChars
                   UNION
                   SELECT dataset_name, dataset_type, dataset_subtype, organism
                   FROM &prefixInferredParams
                   UNION
                   SELECT dataset_name, dataset_type, dataset_subtype, organism
                   FROM &prefixDefaultChars
             ) t
            GROUP BY dataset_name
          )
        SELECT coalesce(term_synonym.name, ot.name) as ontology_term_name, dot.ontology_term_id,
          ot.source_id as ontology_term_source_id,
          term_synonym.definition as description,
          coalesce(term_synonym.name,
             case ot.name
               when 'env_feature' then 'Habitat'
               when 'data set' then 'Data Set'
               when 'obsolete_average mapping coverage' then 'Average mapping coverage'
               else ot.name
             end) as display_name,
          term_synonym.display_order,
          term_synonym.variable,
          cast(null as varchar(10)) as variable_name,
          parent.parent_ontology_term_name, parent.parent_ontology_term_id,
          parent.parent_ontology_term_source_id, unit_term.name as units,
          cast(pt.type as varchar(20)) as type,
          case
           when pt.filter = 'range' then 1
           else 0
          end as is_range,
          cast(1 as numeric(1)) as precision,
          di.organism, dot.dataset_name, di.dataset_type, di.dataset_subtype
        FROM DatasetOntologyTerm dot
          INNER JOIN sres.OntologyTerm ot ON dot.ontology_term_id = ot.ontology_term_id
          INNER JOIN &prefixHierarchyMap hmap ON dot.dataset_name = hmap.dataset_name
          INNER JOIN DatasetInfo di ON dot.dataset_name = di.dataset_name
          LEFT JOIN &prefixDatasetTerm term_synonym ON dot.ontology_term_id = term_synonym.ontology_term_id AND hmap.hierarchy_dataset_name = term_synonym.hierarchy_dataset_name
          LEFT JOIN &prefixPropertyType pt ON dot.ontology_term_id = pt.property_id
          LEFT JOIN sres.OntologyTerm unit_term ON dot.unit_id = unit_term.ontology_term_id
          LEFT JOIN (
            SELECT orel.hierarchy_dataset_name, orel.child_ontology_term_id,
                   orel.parent_ontology_term_id, orel.parent_ontology_term_source_id,
                   coalesce(dt.name, ot.name) as parent_ontology_term_name
            FROM &prefixOntologyRelation orel
              INNER JOIN sres.OntologyTerm ot ON orel.parent_ontology_term_id = ot.ontology_term_id
              LEFT JOIN &prefixDatasetTerm dt ON orel.parent_ontology_term_id = dt.ontology_term_id AND orel.hierarchy_dataset_name = dt.hierarchy_dataset_name
          ) parent ON dot.ontology_term_id = parent.child_ontology_term_id AND hmap.hierarchy_dataset_name = parent.hierarchy_dataset_name
        WHERE dot.dataset_name not in ('ISASimple_RSRC', 'ISA_RSRC')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixOntology&1 o
        SET type
            = (SELECT max(object.name) -- e.g. "multifilter"
               FROM sres.OntologyRelationship orel,
                    sres.OntologyTerm predicate, sres.OntologyTerm object,
                    sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
                    &prefixHierarchyMap hmap
               WHERE o.ontology_term_id = orel.subject_term_id
                 AND orel.predicate_term_id = predicate.ontology_term_id
                 AND predicate.source_id = 'EUPATH_0000271' -- "termType"
                 AND orel.object_term_id = object.ontology_term_id
                 AND orel.external_database_release_id = edr.external_database_release_id
                 AND edr.external_database_id = ed.external_database_id
                 AND ed.name = hmap.hierarchy_dataset_name
                 AND hmap.dataset_name = o.dataset_name
              )
        WHERE type IS NULL
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index &prefixnmoidx1&1
          on &prefixOntology&1 (ontology_term_name, dataset_name, organism)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index &prefixnouqidx1&1
          on &prefixOntology&1 (ontology_term_name, ontology_term_source_id, dataset_name, dataset_type)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixOntology&1
        SET display_name = 'Organism'
        WHERE lower(ontology_term_name) = 'parasite organism'
          AND lower(substr(current_database(), 1, 4)) = 'fung'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="Samples" prefixEnabled="true">
    <comment>lots of columns for sample meta data. used for sample record
      </comment>
    <internalDependency name="InferredParams"/>
    <internalDependency name="PropertyType"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <ancillaryTable name="Participants"/>
    <ancillaryTable name="Observations"/>
    <ancillaryTable name="LightTraps"/>
    <ancillaryTable name="Households"/>
    <ancillaryTable name="Communitys"/>
    <program commandLine="buildPANRecordAttributesTT"/>
  </tuningTable>

  <!-- Renamed from MetadataType -->
  <tuningTable name="PropertyType" prefixEnabled="true">
    <comment>
       Data type and filter method for metadata properties.
    </comment>
    <internalDependency name="DefaultChars"/>
    <internalDependency name="InferredParams"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPropertyType&1 AS
        WITH pan_metadata
             AS (  SELECT property, value, property_id
                   FROM &prefixInferredParams
                 UNION
                   SELECT property, value, property_id
                   FROM &prefixInferredChars
                 UNION
                   SELECT property, value, property_id
                   FROM &prefixDefaultChars
                ),
             term_attributes
             AS (SELECT MAX(property) as property, property_id, COUNT(DISTINCT value) AS distinct_values,
                        MIN(apidb.is_number(value)) AS is_number,
                        MIN(apidb.is_date(value)) AS is_date
                 FROM pan_metadata
                 WHERE value IS NOT NULL
                 GROUP BY property_id
                )
        SELECT ta.property AS property, ot.ontology_term_id as property_id, ot.source_id as property_source_id,
               CASE
                 WHEN ta.is_date = 1
                   THEN 'date'
                 WHEN ta.is_number = 1
                   THEN 'number'
                 ELSE 'string'
               END AS type,
               CASE
                 WHEN ta.is_date = 1
                   THEN 'range'
                 WHEN ta.is_number = 1
                      AND ta.distinct_values > 10
                      AND lower(ta.property) NOT LIKE '%code%'
                   THEN 'range'
                 ELSE 'membership'
               END AS filter,
               ta.distinct_values
        FROM term_attributes ta
         LEFT JOIN sres.OntologyTerm ot ON ta.property_id = ot.ontology_term_id
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX proptypename_idx&1
          ON &prefixPropertyType&1 (property_id, property)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX proptypid_idx&1
          ON &prefixPropertyType&1 (property, property_id, type, filter)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        UPDATE &prefixPropertyType&1
        SET type = 'string', filter = 'membership'
        WHERE property = 'Family ID'
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComComObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for community to community observation relation
    </comment>
<!--
    <internalDependency name="PANIO"/>
-->
    <sql>
      <![CDATA[
        CREATE TABLE &prefixComComObsIO&1 (
          community_id,
          community_observation_id
          )
        AS
        SELECT distinct input_pan_id as community_id, output_pan_id as community_observation_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0035127'
          AND output_pan_type_source_id = 'EUPATH_0035127'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixcomcomobsio_pk&1
          ON &prefixComComObsIO&1 (community_observation_id,community_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComHouseIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to community observation relation
    </comment>
    <!--
        <internalDependency name="PANIO"/>
    -->
    <sql>
      <![CDATA[
        CREATE TABLE &prefixComHouseIO&1 (
          community_id,
          household_id
        )
        AS
        SELECT DISTINCT input_pan_id as community_id, output_pan_id as household_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0035127'
          AND output_pan_type_source_id = 'PCO_0000024'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixcomhouseio_idx&1
          ON &prefixComHouseIO&1 (household_id,community_id)

      ]]>
    </sql>
  </tuningTable>

  <!-- note that there may be direct com to part outputs as not requirement that all participants have a house as per washB -->
  <tuningTable name="ComPartIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to participant relation
    </comment>
    <internalDependency name="ComHouseIO"/>
    <internalDependency name="HousePartIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixComPartIO&1 (
          community_id,
          participant_id
          )
        AS
        SELECT DISTINCT ch.community_id, hp.participant_id
        FROM &prefixComHouseIO ch,  &prefixHousePartIO hp
        WHERE ch.household_id = hp.household_id
        UNION
        SELECT DISTINCT input_pan_id as community_id, output_pan_id as participant_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0035127'
          AND output_pan_type_source_id = 'EUPATH_0000096'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixpartcomio&1
          ON &prefixComPartIO&1 (participant_id,community_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to observation relation
    </comment>
    <internalDependency name="ComPartIO"/>
    <internalDependency name="PartObsIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixComObsIO&1 (
          community_id,
          observation_id
          )
        AS
        SELECT distinct cp.community_id, po.observation_id
        FROM &prefixComPartIO cp,  &prefixPartObsIO po
        WHERE cp.participant_id = po.participant_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixobscomio&1
          ON &prefixComObsIO&1 (observation_id,community_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ComSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for comunity to sample relation
    </comment>
    <internalDependency name="ComObsIO"/>
    <internalDependency name="ObsSampleIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixComSampleIO&1 (
          community_id,
          sample_id
          )
        AS
        SELECT distinct co.community_id, os.sample_id
        FROM &prefixComObsIO co,  &prefixObsSampleIO os
        WHERE co.observation_id = os.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsamplecomio&1
          ON &prefixComSampleIO&1 (sample_id,community_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="CommunityMD" prefixEnabled="true">
    <comment>
      Metadata table specific for community metadata in community filter
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="Ontology"/>
    <internalDependency name="ComComObsIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixCommunityMD&1 (
          ontology_term_name,
          community_id,
          string_value,
          number_value,
          date_value
          )
        AS
        SELECT distinct m.property_source_id as ontology_term_name,
         m.pan_id as community_id, m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m
        WHERE m.property_source_id in (
          WITH RECURSIVE cte AS (
              SELECT ontology_term_source_id
              FROM &prefixOntology
              WHERE ontology_term_source_id in ('EUPATH_0035127')
              UNION
              SELECT o.ontology_term_source_id
              FROM cte, &prefixOntology o
              WHERE o.parent_ontology_term_source_id = cte.ontology_term_source_id
          )
          SELECT DISTINCT ontology_term_source_id
          FROM cte
        )
          AND m.pan_id not in (SELECT DISTINCT community_observation_id FROM &prefixComComObsIO)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixcomunmd_pk&1
          ON &prefixCommunityMD&1 (ontology_term_name,community_id,string_value)

      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="CommunityObsMD" prefixEnabled="true">
    <comment>
      Metadata table specific for community observation metadata in community filter
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="Ontology"/>
    <internalDependency name="ComComObsIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixCommunityObsMD&1 (
          ontology_term_name,
          community_observation_id,
          string_value,
          number_value,
          date_value
          )
        AS
        SELECT DISTINCT m.property_source_id as ontology_term_name,
          m.pan_id as community_observation_id, m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m
        WHERE m.property_source_id in (
          WITH RECURSIVE cte AS (
            SELECT ontology_term_source_id
            FROM &prefixOntology
            WHERE ontology_term_source_id in ('EUPATH_0035127')
            UNION
            SELECT o.ontology_term_source_id
            FROM cte, ontology o
            WHERE o.parent_ontology_term_source_id = cte.ontology_term_source_id
          )
          SELECT DISTINCT ontology_term_source_id
          FROM cte
        )
          AND m.pan_id in (SELECT DISTINCT community_observation_id FROM &prefixComComObsIO)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixcomunobsmd_pk&1
          ON &prefixCommunityObsMD&1 (ontology_term_name,community_observation_id,string_value)

      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="HouseholdMD" prefixEnabled="true">
    <comment>
      Metadata table specific for household filter in household record
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="Ontology"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixHouseholdMD&1 (
          ontology_term_name,
          household_id,
          household_observation_id,
          string_value,
          number_value,
          date_value
          )
        AS
        with iopo AS (
          SELECT distinct hp.input_pan_id as household_id, po.output_pan_id as observation_id
          FROM &prefixPANIO hp, &prefixPANIO po
          WHERE hp.input_pan_type_source_id = 'PCO_0000024' AND hp.output_pan_type_source_id = 'EUPATH_0000096'
            AND hp.output_pan_id = po.input_pan_id
            AND po.input_pan_type_source_id = 'EUPATH_0000096' AND po.output_pan_type_source_id = 'EUPATH_0000738'
        ),
        ioho AS (
          SELECT distinct hp.input_pan_id as household_id, hp.output_pan_id as observation_id
          FROM &prefixPANIO hp
          WHERE hp.input_pan_type_source_id = 'PCO_0000024' AND hp.output_pan_type_source_id = 'EUPATH_0000738'
        ),
        iohh as (
          select distinct hp.input_pan_id as household_id, hp.output_pan_id as observation_id
          from &prefixPANIO hp
          where hp.input_pan_type_source_id = 'PCO_0000024' AND hp.output_pan_type_source_id = 'PCO_0000024'
        ),
        hhold as (
          SELECT * from (
           SELECT DISTINCT m.property_source_id as ontology_term_name,
             CASE WHEN ioho.household_id is not null THEN ioho.household_id WHEN iopo.household_id is not null THEN iopo.household_id
             WHEN iohh.household_id is not null THEN iohh.household_id ELSE m.pan_id END as household_id,
             m.pan_id as household_observation_id, m.string_value, m.number_value, m.date_value
           FROM &prefixMetaData m
            LEFT JOIN iopo ON m.pan_id = iopo.observation_id
            LEFT JOIN ioho ON m.pan_id = ioho.observation_id
            LEFT JOIN iohh ON m.pan_id = iohh.observation_id
           WHERE m.property_source_id in (
            WITH RECURSIVE cte AS (
              SELECT ontology_term_source_id
              FROM &prefixOntology
              WHERE ontology_term_source_id in ('PCO_0000024')
              UNION
              SELECT o.ontology_term_source_id
              FROM cte, ontology o
              WHERE o.parent_ontology_term_source_id = cte.ontology_term_source_id
            )
            SELECT DISTINCT ontology_term_source_id
            FROM cte
           )
          ) t
        )
        SELECT * FROM (
          SELECT * FROM hhold
          UNION
          SELECT distinct m.property_source_id as ontology_term_name,
                hh.household_id, hh.household_observation_id, m.string_value, m.number_value, m.date_value
          FROM &prefixMetaData m, (select distinct household_observation_id, household_id from hhold) hh
          WHERE m.property_source_id = 'EUPATH_0000579'
            AND m.pan_id = hh.household_observation_id
        ) t
        ORDER BY ontology_term_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixHhmd_pk&1
          ON &prefixHouseholdMD&1 (ontology_term_name,household_id,household_observation_id,string_value)

      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="ParticipantMD" prefixEnabled="true">
    <comment>
      Metadata table specific for participant filter in participant record
    </comment>
    <internalDependency name="Metadata"/>
    <internalDependency name="PANIO"/>
    <internalDependency name="Ontology"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixParticipantMD&1 (
          ontology_term_name,
          participant_id,
          household_id,
          string_value,
          number_value,
          date_value
        )
        AS
        SELECT * FROM (
          SELECT DISTINCT m.property_source_id as ontology_term_name, m.pan_id as participant_id, io.input_pan_id as household_id, m.string_value, m.number_value, date_value
          FROM &prefixMetaData m
           LEFT JOIN (SELECT input_pan_id, output_pan_id FROM &prefixPANIO WHERE input_pan_type_source_id = 'PCO_0000024') io
            ON m.pan_id = io.output_pan_id
          WHERE m.property_source_id in (
            WITH RECURSIVE cte AS (
              SELECT ontology_term_source_id
              FROM &prefixOntology
              WHERE ontology_term_source_id in ('EUPATH_0000096')
              UNION
              SELECT o.ontology_term_source_id
              FROM cte, ontology o
              WHERE o.parent_ontology_term_source_id = cte.ontology_term_source_id
            )
            SELECT DISTINCT ontology_term_source_id
            FROM cte
          )
        ) t
        ORDER BY ontology_term_name,participant_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixPpartmd_pk&1
          ON &prefixParticipantMD&1 (ontology_term_name,participant_id,string_value)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HousePartIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to participant relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixHousePartIO&1 (
          household_id,
          participant_id
          )
        AS
        SELECT DISTINCT input_pan_id as household_id, output_pan_id as participant_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'PCO_0000024'
          AND output_pan_type_source_id = 'EUPATH_0000096'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixparthouseio&1
          ON &prefixHousePartIO&1 (participant_id,household_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HouseObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to observation relation
    </comment>
    <internalDependency name="HousePartIO"/>
    <internalDependency name="PartObsIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixHouseObsIO&1 (
          household_id,
          observation_id
          )
        AS
        SELECT hp.household_id, po.observation_id
        FROM &prefixPartObsIO po, &prefixHousePartIO hp
        WHERE po.participant_id = hp.participant_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixobshouseio&1
          ON &prefixHouseObsIO&1 (observation_id,household_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="PartObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for participant to observation relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPartObsIO&1 ( participant_id, observation_id )
        AS
        SELECT DISTINCT input_pan_id as participant_id, output_pan_id as observation_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0000096'
            AND output_pan_type_source_id = 'EUPATH_0000738'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixobspartio&1
          ON &prefixPartObsIO&1 (observation_id,participant_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="ObsSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for Observation to Sample relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixobssampleio&1 (
          observation_id,
          sample_id
        )
        AS
        SELECT distinct input_pan_id as observation_id, output_pan_id as sample_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0000738'
          AND output_pan_type_source_id = 'EUPATH_0000609'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsampleobsio&1
          ON &prefixObsSampleIO&1 (sample_id, observation_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HouseSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to observation relation
    </comment>
    <internalDependency name="HousePartIO"/>
    <internalDependency name="PartObsIO"/>
    <internalDependency name="ObsSampleIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixHouseSampleIO&1 (
          household_id,
          sample_id
        )
        AS
        SELECT hp.household_id, os.sample_id
        FROM &prefixPartObsIO po, &prefixHousePartIO hp, &prefixObsSampleIO os
        WHERE po.participant_id = hp.participant_id
          AND po.observation_id = os.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsplhouseio&1
          ON &prefixHouseSampleIO&1 (sample_id,household_id)

      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="PartSampleIO" prefixEnabled="true">
    <comment>
      Metadata table specific for participant to sample relation
    </comment>
    <internalDependency name="PartObsIO"/>
    <internalDependency name="ObsSampleIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixPartSampleIO&1 (
          participant_id,
          sample_id
        )
        AS
        SELECT po.participant_id, os.sample_id
        FROM &prefixPartObsIO po, &prefixObsSampleIO os
        WHERE po.observation_id = os.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsplPartio&1
          ON &prefixPartSampleIO&1 (sample_id,participant_id)

      ]]>
    </sql>
  </tuningTable>
  
  <tuningTable name="ObsObsIO" prefixEnabled="true">
    <comment>
      Metadata table specific for Observation to sub observation relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixObsObsIO&1 (
          observation_id,
          sub_observation_id
          )
        AS
        SELECT DISTINCT input_pan_id as observation_id, output_pan_id as sub_observation_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0000738'
          AND output_pan_type_source_id = 'EUPATH_0000738'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixsubobsobsio&1
          ON &prefixObsObsIO&1 (sub_observation_id, observation_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="HouseEntoIO" prefixEnabled="true">
    <comment>
      Metadata table specific for household to Entomology relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixHouseEntoIO&1 (
          household_id,
          entomology_id
          )
        AS
        SELECT DISTINCT input_pan_id as household_id, output_pan_id as entomology_id
        FROM &prefixpanio
        WHERE input_pan_type_source_id = 'PCO_0000024'
          AND output_pan_type_source_id = 'EUPATH_0000327'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixhouseentoio_idx&1
          ON &prefixHouseEntoIO&1 (entomology_id,household_id)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="EntoInsSplIO" prefixEnabled="true">
    <comment>
      Metadata table specific for Entomology to insect sample relation
    </comment>
    <internalDependency name="PANIO"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixEntoInsSplIO&1 (
          entomology_id,
          insect_sample_id
          )
        AS
        SELECT distinct input_pan_id as entomology_id, output_pan_id as insect_sample_id
        FROM &prefixPANIO
        WHERE input_pan_type_source_id = 'EUPATH_0000327'
          AND output_pan_type_source_id = 'EUPATH_0025169'
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixentoinssplio_idx&1
          ON &prefixEntoInsSplIO&1 (insect_sample_id,entomology_id)

      ]]>
    </sql>
  </tuningTable>

  <!-- NOTE: this will NOT work for studies where sub observations have samples -->
  <tuningTable name="ObservationMD" prefixEnabled="true">
    <comment>
      Metadata table specific for observation filter 
    </comment>
    <internalDependency name="ObsObsIO"/>
    <internalDependency name="HousePartIO"/>
    <internalDependency name="PartObsIO"/>
    <internalDependency name="Metadata"/>
    <internalDependency name="ObsSampleIO"/>
    <internalDependency name="Ontology"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixObservationMD&1 (
          ontology_term_name,
          observation_id,
          participant_id,
          sub_observation_id,
          sample_id,
          household_id,
          string_value,
          number_value,
          date_value
          )
        AS
        WITH obsont AS (
          WITH RECURSIVE cte AS (
            SELECT ontology_term_source_id
            FROM &prefixOntology
            /* NOTE: 'EUPATH_0000609' bring in sample vars attached directly to observations like for PRISM */
            WHERE ontology_term_source_id in ('EUPATH_0000738','EUPATH_0000609')
            UNION
            SELECT o.ontology_term_source_id
            FROM cte, ontology o
            WHERE o.parent_ontology_term_source_id = cte.ontology_term_source_id
          )
          SELECT DISTINCT ontology_term_source_id
          FROM cte
        )
        SELECT DISTINCT m.property_source_id as ontology_term_name, m.pan_id as observation_id, ioo.participant_id,  m.pan_id as sub_observation_id,
               m.pan_id as sample_id, coalesce(ioh.household_id,-1) as household_id, m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m
          INNER JOIN &prefixPartObsIO ioo ON m.pan_id = ioo.observation_id
          LEFT JOIN &prefixHousePartIO ioh ON ioo.participant_id = ioh.participant_id
        WHERE m.property_source_id in ( SELECT ontology_term_source_id FROM obsont )
        UNION  -- NOTE: the following pulls in sub-observations for an observation but maintains as separate observations
        SELECT distinct m.property_source_id as ontology_term_name, iosub.observation_id as observation_id, ioo.participant_id, m.pan_id as sub_observation_id, iosub.observation_id as sample_id,
                coalesce(ioh.household_id,-1) as household_id, m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m, &prefixObsObsIO iosub, &prefixPartObsIO ioo
          LEFT JOIN &prefixHousePartIO ioh ON ioo.participant_id = ioh.participant_id
        WHERE m.property_source_id in (SELECT ontology_term_source_id from obsont)
          and m.pan_id = iosub.sub_observation_id
          and iosub.observation_id = ioo.observation_id
        UNION --NOTE: next block pulls in sample information
        SELECT DISTINCT m.property_source_id as ontology_term_name, ioo.observation_id,ioo.participant_id, ioo.observation_id as sub_sample_id,
               m.pan_id as sample_id, coalesce(ioh.household_id,-1) as household_id,  m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m, &prefixObsSampleIO spec, &prefixPartObsIO ioo
          LEFT JOIN &prefixHousePartIO ioh ON ioo.participant_id = ioh.participant_id
        WHERE m.property_source_id in (
          WITH RECURSIVE cte AS (
            SELECT ontology_term_source_id
            FROM &prefixOntology
            WHERE ontology_term_source_id in ('EUPATH_0000609')
            UNION
            SELECT o.ontology_term_source_id
            FROM cte, ontology o
            WHERE o.parent_ontology_term_source_id = cte.ontology_term_source_id
          )
          SELECT DISTINCT ontology_term_source_id
          FROM cte
        )
          AND m.pan_id = spec.sample_id
          AND ioo.observation_id = spec.observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixObsmd_partid&1
          ON &prefixObservationMD&1 (participant_id, observation_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixObsmd_obsid&1
          ON &prefixObservationMD&1 (observation_id, participant_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixObsmd_pk&1
          ON &prefixObservationMD&1 (ontology_term_name,observation_id,participant_id,sub_observation_id,sample_id,string_value)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="SampleMD" prefixEnabled="true">
    <comment>
      Metadata table specific for sample filter 
    </comment>
    <internalDependency name="ObservationMD"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixSampleMD&1 (
          ontology_term_name,
          sample_id,
          observation_id,
          participant_id,
          household_id,
          string_value,
          number_value,
          date_value
          )
        AS
        SELECT ontology_term_name, sample_id, observation_id, participant_id, household_id, string_value, number_value, date_value
        FROM &prefixObservationMD
        WHERE sample_id != observation_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixSplmd_obsid&1
          ON &prefixSampleMD&1 (observation_id, sample_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixSplmd_pk&1
          ON &prefixSampleMD&1 (ontology_term_name,sample_id,observation_id,participant_id,string_value)

      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="EntomologyMD" prefixEnabled="true">
    <comment>
      Metadata table specific for observation filter 
    </comment>
    <internalDependency name="HouseEntoIO"/>
    <internalDependency name="EntoInsSplIO"/>
    <internalDependency name="Metadata"/>
    <sql>
      <![CDATA[
        CREATE TABLE &prefixEntomologyMD&1 (
          ontology_term_name,
          entomology_id,
          household_id,
          insect_sample_id,
          string_value,
          number_value,
          date_value
          )
        AS
        SELECT DISTINCT m.property_source_id as ontology_term_name, m.pan_id as entomology_id, io.household_id,  m.pan_id as insect_sample_id,
               m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m, &prefixHouseEntoIO io
        WHERE m.pan_id = io.entomology_id
        UNION  -- NOTE: the following pulls in insect sample data
        SELECT distinct m.property_source_id as ontology_term_name, eis.entomology_id, io.household_id,  m.pan_id as insect_sample_id,
              m.string_value, m.number_value, m.date_value
        FROM &prefixMetaData m, &prefixHouseEntoIO io, &prefixEntoInsSplIO eis
        WHERE m.pan_id = Eis.Insect_Sample_Id
          AND Eis.Entomology_Id = io.entomology_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixEntomd_houseid&1
          ON &prefixEntomologyMD&1 (household_id, entomology_id)

      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX &prefixEntomd_pk&1
          ON &prefixEntomologyMD&1 (ontology_term_name,entomology_id,household_id,insect_sample_id,string_value)

      ]]>
    </sql>
  </tuningTable>

<!-- CHECK AND FIX - regexp_substr issue
  <tuningTable name="RecordCount" prefixEnabled="false">
    <comment>generates the counts for each type_id for each study in study.protocolappnode.
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="sres.OntologyTerm"/>
    <sql>
      <![CDATA[
        CREATE TABLE RecordCount&1 AS
        WITH coredata AS (
          SELECT inv.algorithm_invocation_id, inv.comment_string, o.ontology_term_id,o.name,count(*) as record_count
          FROM study.protocolappnode pan, sres.ontologyterm o, core.algorithminvocation inv
          WHERE o.ontology_term_id = pan.type_id
            AND inv.algorithm_invocation_id = pan.row_alg_invocation_id
            AND pan.protocol_app_node_id not in (
               SELECT distinct panout.protocol_app_node_id
               FROM study.input, study.output, study.protocolappnode panin, study.protocolappnode panout, sres.ontologyterm otin, sres.ontologyterm otout
               WHERE input.protocol_app_id = output.protocol_app_id
                 AND input.protocol_app_node_id = panin.protocol_app_node_id
                 AND panin.type_id = otin.ontology_term_id
                 AND otin.name = 'Household'
                 AND output.protocol_app_node_id = panout.protocol_app_node_id
                 AND panout.type_id = otout.ontology_term_id
                 AND otout.name = 'Household'
            )
          GROUP BY inv.algorithm_invocation_id,inv.comment_string, o.ontology_term_id,o.name
        )
        SELECT dp.dataset_presenter_id, dp.name, dp.display_name, t.name as record_type, t.record_count
        FROM datasetpresenter dp,  coredata t
        WHERE dp.name = regexp_replace(regexp_substr(t.comment_string,'extDbRlsSpec\s+["'']\S+RSRC'),'extDbRlsSpec\s+["'']','')
      ]]>
    </sql>
    <sql>
      <![CDATA[
        INSERT INTO RecordCount&1
        SELECT tp.dataset_presenter_id,dp.name,dp.display_name, 'Variable' AS RECORD_TYPE, count(o.ONTOLOGY_SYNONYM_ID) AS RECORD_COUNT
        FROM DATASETProperty tp
          LEFT JOIN apidbtuning.datasetpresenter dp ON tp.dataset_presenter_id=dp.dataset_presenter_id
          LEFT JOIN sres.EXTERNALDATABASE e ON e.name= 'OntologyTerm_' || tp.value || '_RSRC'
          LEFT JOIN sres.EXTERNALDATABASERELEASE rel ON e.EXTERNAL_DATABASE_ID = rel.EXTERNAL_DATABASE_ID
          LEFT JOIN sres.ONTOLOGYSYNONYM o ON rel.EXTERNAL_DATABASE_RELEASE_ID = o.EXTERNAL_DATABASE_RELEASE_ID
        WHERE tp.property='webDisplayOntologyName'
        GROUP BY tp.dataset_presenter_id,dp.name,dp.display_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index rcd_ct_ix&1
        on RecordCount&1 (dataset_presenter_id, record_type)

      ]]>
    </sql>
  </tuningTable>
-->
</tuningConfig>
